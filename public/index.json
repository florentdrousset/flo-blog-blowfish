[{"content":"","date":"12 novembre 2023","permalink":"/","section":"Florent Drousset","summary":"","title":"Florent Drousset"},{"content":" OCaml, my üê´ # I\u0026rsquo;ve started learning OCaml very recently and, oh boy, it\u0026rsquo;s been a hell of a ride. The language I\u0026rsquo;ve worked with the most in my life is PHP. I\u0026rsquo;ve studied a bit of C and Java at school, and as a web developer I obviously can\u0026rsquo;t avoid coding in Javascript, but most of what I\u0026rsquo;ve learned at school and used at work was (and still is) PHP. Which means that the functional paradigm has been absolutely unknown to me until then.\nI enjoy programming on my free time, but it\u0026rsquo;s sometimes difficult to stay focused on a goal when there are no deadlines or obligations attached to that goal. I\u0026rsquo;ve also noticed that I get bored pretty quick whenever I try to learn a new language that has features/paradigm similar to PHP : it\u0026rsquo;s not so exciting to rewrite the same thing or do the same projects with just a different syntax. Another thing that feels exciting is that the OCaml ecosystem for web is not as developped as other more mainstream languages. It feels like there are styll many things to do and lots of code to write, which feels great to me.\nI came across OCaml code for the first time very recently and was hooked by the expressive syntax of the language. Being used to imperative languages and not having a very long academic background makes learning OCaml quite tricky, to say the least, but it also makes the process very exciting, and it feels like discovering a whole new world.\nBut enough said about me : the goal of the following serie of articles is to provey a very quick introduction to the language, from the eyes of a web developer used to PHP.\nI will spare you the basic details that you can easily find on Wikipedia (or even better : ocaml.org), but OCaml (Objective Caml) is the last implemenation of the language Caml, that was created in France (cocorico !) in 1987.\nInstallation # The first thing that you will need is opam, the package manager for OCaml (that\u0026rsquo;s like composer, right ??)\nbash -c \u0026#34;sh \u0026lt;(curl -fsSL https://raw.githubusercontent.com/ocaml/opam/master/shell/install.sh)\u0026#34; You can then initialize opam, which will create an opan switch with :\nopam init Answer YES when asked if you want a hook to your shell.\nAn opam switch is an installation of an ocaml which comes with several parameters : compiler version, installed packages, etc. You can easily switch between different \u0026ldquo;ocaml environments\u0026rdquo; (my words, that might not be the proper terminology) by doing\nopam switch \u0026lt;switch-name\u0026gt; If you just type opam switch, you\u0026rsquo;ll see all the switches you have available.\nYou can then install packages like this :\nopam install dune By running this command, you\u0026rsquo;ll install https://github.com/ocaml/dune, the build system for OCaml. Other interesting packages to install would be https://github.com/ocaml/merlin (auto-completion for vim/emacs), and also https://opam.ocaml.org/blog/about-utop/ (an improved interface for the toplevel REPL for OCaml)\nThis is just the first article on a serie. Now that a basic environment has been set up, we\u0026rsquo;ll start writing some actual code in the next article.\n","date":"12 novembre 2023","permalink":"/posts/learning-ocaml/","section":"Posts","summary":"OCaml, my üê´ # I\u0026rsquo;ve started learning OCaml very recently and, oh boy, it\u0026rsquo;s been a hell of a ride.","title":"Learning Ocaml"},{"content":"","date":"12 novembre 2023","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":" Introduction # Dans ce petit tutoriel, nous allons explorer comment Docker peut simplifier le d√©ploiement d\u0026rsquo;une application web. Plus pr√©cis√©ment, nous allons dockeriser une application web existante, httpbin, et y ajouter une couche de mise en cache avec Redis, le tout orchestr√© par docker compose.\nPr√©requis # Docker install√© sur votre machine Connaissances de base en ligne de commande √âtapes du Tutoriel # 1. Dockerisation de httpbin # Tout d\u0026rsquo;abord, cr√©ons un fichier Dockerfile (voir mon intro √† Dockerfile pour vous rafra√Æchir la m√©moire !) avec le contenu suivant :\n# Nous utiliserons une image python officielle comme image parent FROM python:3.9-slim # On d√©finit le r√©pertoire de travail dans le container WORKDIR /usr/src/app # On installe httpbin et gunicorn RUN pip install httpbin gunicorn # On d√©finit ici la commande √† ex√©cuter lors du d√©marrage du conteneur CMD [\u0026#34;gunicorn\u0026#34;, \u0026#34;-b\u0026#34;, \u0026#34;0.0.0.0:80\u0026#34;, \u0026#34;httpbin:app\u0026#34;] 2. Utilisation de Docker Compose # Cr√©ez un fichier docker-compose.yml :\nversion: \u0026#39;3\u0026#39; services: httpbin: build: context: . dockerfile: Dockerfile ports: - \u0026#34;8080:80\u0026#34; redis: image: \u0026#34;redis:latest\u0026#34; ports: - \u0026#34;6379:6379\u0026#34; Lancez les services avec Docker Compose :\ndocker-compose up 3. Impl√©menter la Persistance des Donn√©es # Ajoutez un volume √† la d√©finition de service Redis dans docker-compose.yml :\nredis: image: \u0026#34;redis:latest\u0026#34; ports: - \u0026#34;6379:6379\u0026#34; volumes: - redis-data:/data Cr√©ez un volume Docker √† coup de docker volume create redis-data. Un volume Docker est une forme de stockage persistant que vous pouvez utiliser avec vos conteneurs Docker. Contrairement √† un dossier mapp√© sur l\u0026rsquo;h√¥te, un volume est compl√®tement g√©r√© par Docker et permet de sauvegarder des donn√©es ind√©pendamment du cycle de vie des conteneurs. Dans notre cas, nous avons utilis√© un volume pour stocker les donn√©es de notre base de donn√©es Redis, afin de ne pas les perdre lorsque le conteneur est arr√™t√© ou supprim√©.\nTester httpbin # Vous pouvez tester le service httpbin de plusieurs mani√®res :\nNavigateur Web : Ouvrez http://localhost:8080 dans votre navigateur.\nCurl : Vous pouvez utiliser curl pour envoyer des requ√™tes HTTP :\ncurl http://localhost:8080/get Tester Redis # Shell Redis : docker exec -it [CONTAINER_ID] redis-cli Puis, une fois dans le shell :\nset user:1 \u0026#34;John Doe\u0026#34; get user:1 Cela va cr√©er une cl√© user:1 avec la valeur \u0026quot;John Doe\u0026quot; et ensuite r√©cup√©rer cette valeur.\nScript ou application : Vous pouvez √©galement utiliser un script Python ou une application pour interagir avec Redis. import redis r = redis.Redis(host=\u0026#39;localhost\u0026#39;, port=6379, db=0) r.set(\u0026#39;user:2\u0026#39;, \u0026#39;Jane Doe\u0026#39;) print(r.get(\u0026#39;user:2\u0026#39;).decode(\u0026#34;utf-8\u0026#34;)) ","date":"24 septembre 2023","permalink":"/posts/dockerize-a-simple-app/","section":"Posts","summary":"Introduction # Dans ce petit tutoriel, nous allons explorer comment Docker peut simplifier le d√©ploiement d\u0026rsquo;une application web.","title":"Dockerizer une app web simple"},{"content":" Pr√©ambule # Pour rappel :\nune image Docker est un template contenant des instructions pour cr√©er un container Docker un fichier Dockerfile permet de d√©finir ces instructions afin de cr√©er une image Docker une image Docker peut comporter plusieurs layers et commence toujours avec un layer de base Pour notre premier test, nous allons utiliser une image de la distro Linux Alpine comme layer de base et y installer vim. La premi√®re instruction de notre Dockerfile (nomm√© Dockerfile) sera donc :\nFROM alpine:latest En effet, une image peut √™tre (et sera la plupart du temps) bas√©e sur une autre image. Pour ce premier exemple, nous nous basons sur la derni√®re version de Alpine. Si nous souhaitions utiliser une version sp√©cifique, on pourrait alors √©crire alpine:3.15.10 (par exemple).\nLa prochaine instruction sera\nRUN apk update \u0026amp;\u0026amp; \\ apk add vim L\u0026rsquo;instruction RUN va cr√©er un nouveau layer Docker et ex√©cuter l\u0026rsquo;instruction pass√©e en param√®tre. En l\u0026rsquo;occurence, les instructions execut√©es seront apk update et apk add vim.\nConstruction de l\u0026rsquo;image # Pour constuire une image √† partir de notre Dockerfile, on utilisera docker build. docker build requiert √† minima un contexte : en l\u0026rsquo;occurence le dossier dans lequel se trouve le Dockerfile. On utilisera √©galement le flag -t afin de tagger notre image avec un nom pour des raisons de praticit√©.\ndocker build -t dockerfile-tutorial . Docker va donc build notre image. Pour v√©rifier si l\u0026rsquo;image a bien √©t√© cr√©√©e :\ndocker images Retour console :\nREPOSITORY TAG IMAGE ID CREATED SIZE dockerfile-tutorial latest 4f21a4e055d1 40 hours ago 41.4MB Construction du container # Bien ! Nous avons notre image, nous pouvons √† pr√©sent cr√©er un container √† partir de celle-ci. Le container sera une instance de notre image qui n\u0026rsquo;est, encore une fois, qu\u0026rsquo;un mod√®le ou template permettant de cr√©er des containers Docker. Pour run un container √† partir de notre image :\ndocker run --rm -ti dockerfile-tutorial /bin/sh Analysons cette commande :\ndocker run : lance un conteneur Docker √† partir d\u0026rsquo;une image sp√©cifi√©e (en l\u0026rsquo;occurence, dockerfile-tutorial)\n--rm: indique √† Docker de supprimer automatiquement le conteneur une fois qu\u0026rsquo;il est arr√™t√©. Sans cette option, on devrait manuellement supprimer le conteneur √† coup de docker rm apr√®s l\u0026rsquo;avoir arr√™t√©.\n-ti: -t alloue un pseudo-TTY : le container sera run avec un terminal interactif. -i : Permet de garder STDIN ouvert, afin de pouvoir interagir avec le container en direct.\nSi tout s\u0026rsquo;est bien pass√©, vous devriez √™tre gratifi√© d\u0026rsquo;un :\n/ # Vous voil√† donc connect√© au terminal de votre nouveau container bas√© sur l\u0026rsquo;image alpine. Comme nous avions sp√©cifi√© l\u0026rsquo;installation de vim dans le Dockerfile, nous pouvons tester si celui-ci fonctionne bien :\nvim Nous voil√† sur vim, lanc√© depuis notre nouveau container construit √† partir du Dockefile que nous avons √©crit. :q + entr√©e pour quitter vim, et taper exit pour quitter le container.\ndocker ps permet de lister tous les containers actifs. Comme nous venons de quitter notre container, celui-ci ne devrait pas appara√Ætre dans cette liste.\nUn mot sur les layers # Chaque instruction de notre Dockerfile construit un nouveau layer au-dessus du pr√©c√©dent. Ceux-ci sont automatiquement mis en cache par Docker lors du build : Docker essayera toujours de r√©cup√©rer un layer en cache apr√®s avoir v√©rifi√© si celui-ci a √©t√© modifi√©.\nSi un layer a chang√© depuis le dernier build, tous les layers suivants seront rebuild. L\u0026rsquo;optimisation du cache dans Docker fera probablement l\u0026rsquo;objet d\u0026rsquo;un article √† part enti√®re, mais vous pouvez vous r√©f√©rer √† l\u0026rsquo;article d√©di√© dans la documentation officielle de Docker.\nReprenons le retour console lorsque que nous ex√©cutons la commande docker build -t dockerfile-tutorial . :\n[+] Building 0.4s (7/7) FINISHED =\u0026gt; [internal] load build definition from Dockerfile 0.0s =\u0026gt; =\u0026gt; transferring dockerfile: 88B 0.0s =\u0026gt; [internal] load .dockerignore 0.0s =\u0026gt; =\u0026gt; transferring context: 2B 0.0s =\u0026gt; [internal] load metadata for docker.io/library/alpine:latest 0.4s =\u0026gt; [1/3] FROM docker.io/library/alpine:latest@sha256:7144f7bab3d4c2648d7e59409f15ec52a18006a128c733fcff20d3a4a54ba44a 0.0s =\u0026gt; CACHED [2/3] RUN apk update 0.0s =\u0026gt; CACHED [3/3] RUN apk add vim 0.0s =\u0026gt; exporting to image 0.0s =\u0026gt; =\u0026gt; exporting layers 0.0s =\u0026gt; =\u0026gt; writing image sha256:011e7455dac2771e18a365a9e9fae2951eb199c7f0b901b7b2cbb60ef5cdaa68 0.0s =\u0026gt; =\u0026gt; naming to docker.io/library/dockerfile-tutorial On peut constater que 3 layers ont √©t√© lanc√©s : 1 - le layer de base : l\u0026rsquo;image alpine:latest 2 - l\u0026rsquo;instruction RUN apk update (r√©cup√©r√©e du cache) 3 - l\u0026rsquo;instruction RUN apk add vim (√©galement r√©cup√©r√©e du cache)\nAvoir une bonne compr√©hension des layers est important pour comprendre la construction des images Docker.\nVers des images plus complexes # Bien, nous savons d√©sormais nous baser sur une image pr√©-existante avec l\u0026rsquo;instruction FROM et ex√©cuter des commandes avec l\u0026rsquo;instruction RUN. Prenons un nouvel exemple et essayons de nous lancer dans une cr√©ation d\u0026rsquo;image plus complexe : l\u0026rsquo;installation du framework PHP Symfony.\nVoici le fichier Dockerfile complet :\nFROM php:8.0-apache RUN apt-get update \u0026amp;\u0026amp; apt-get install -y \\ libpng-dev \\ libjpeg62-turbo-dev \\ libxml2-dev \\ libicu-dev \\ git \\ unzip RUN docker-php-ext-configure gd --with-jpeg=/usr/include/ \\ \u0026amp;\u0026amp; docker-php-ext-install gd pdo pdo_mysql opcache intl RUN a2enmod rewrite RUN curl -sS https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer WORKDIR /var/www/html RUN composer create-project symfony/skeleton my_project_name ENV APACHE_DOCUMENT_ROOT /var/www/html/my_project_name/public RUN sed -ri -e \u0026#39;s!/var/www/html!${APACHE_DOCUMENT_ROOT}!g\u0026#39; /etc/apache2/sites-available/*.conf EXPOSE 80 CMD [\u0026#34;apache2-foreground\u0026#34;] Sont ici pr√©sentes 4 instructions Dockerfile que nous n\u0026rsquo;avons pas encore vues : WORKDIR, ENV, EXPOSE et CMD.\nReprenons les diff√©rentes instructions une par une.\nNous commencons par nous baser sur l\u0026rsquo;image officielle de php-apache. Les deux RUN suivants installent toutes les librairies requises pour l\u0026rsquo;installation de Symfony, suivi d\u0026rsquo;une modification de config du serveur Apache (RUN a2enmod rewrite).\nWORKDIR d√©finit simplement le dossier dans lequel les commandes suivantes seront ex√©cut√©es. Il est l\u0026rsquo;√©quivalent du cd, √† ceci pr√®s qu\u0026rsquo;il cr√©era le dossier (donc √©galement √©quivalent du mkdir) si celui-ci n\u0026rsquo;existe pas d√©j√† !\nENV permet de d√©finir une variable d\u0026rsquo;environnement qui pourra √™tre r√©utilis√©e par la majeure partie des instructions Dockerfile.\nENV APACHE_DOCUMENT_ROOT /var/www/html/my_project_name/public Une autre syntaxe existe : ENV nom_de_variable=\u0026quot;valeur\u0026quot;\nIci, la variable d\u0026rsquo;environnement APACHE_DOCUMENT_ROOT d√©finie apr√®s ENV est r√©utilis√©e comme ceci : ${APACHE_DOCUMENT_ROOT}. Note : dans certains cas, on pr√©f√®rera utiliser l\u0026rsquo;instruction ARG qui permet de d√©finir des variables utilis√©es uniquement au moment du build et qui ne seront pas persist√©es dans le container.\nEXPOSE informe Docker que le container devra √©couter sur le port sp√©cifi√©. EXPOSE est configur√© en TCP par d√©faut, mais on peut lui sp√©cifier d\u0026rsquo;utiliser le protocole UDP si n√©cessaire :\nEXPOSE 80/udp CMD d√©finit la commande execut√©e par d√©faut lorsque le container est lanc√©. Il ne peut y avoir qu\u0026rsquo;une seule instruction CMD par Dockerfile ! (Notez que si plusieurs sont pr√©sentes, seule la derni√®re sera execut√©e.) Il est possible de surcharger CMD au moment du run avec la syntaxe suivante : docker run $image $autre_commande\nEt voil√† ! On peut donc build notre image, puis lancer le container :\ndocker build -t test-symfony . docker run -p 8080:80 test-symfony -p nous permet de sp√©ficier les ports utilis√©s par notre container. Le premier nombre d√©finit le port utilis√© physiquement sur votre machine, et le lie au deuxi√®me nombre qui d√©finit le port utilis√© dans le container. Rendez-vous sur localhost:8080 pour voir la page d\u0026rsquo;accueil de Symfony.\nCet article n\u0026rsquo;√©tait qu\u0026rsquo;une introduction aux fichiers Dockerfile qui ne fait qu\u0026rsquo;effleurer les possibilit√©s de la construction d\u0026rsquo;image Docker. La deuxi√®me partie suivra bient√¥t pour aborder d\u0026rsquo;autres notions importantes.\n","date":"19 ao√ªt 2023","permalink":"/posts/dockerfile-basics/","section":"Posts","summary":"Pr√©ambule # Pour rappel :","title":"Les bases de Dockerfile - Partie I"},{"content":"","date":"1 janvier 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 janvier 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 janvier 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"1 janvier 0001","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]